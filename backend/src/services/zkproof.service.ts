const snarkjs = require('snarkjs');
import * as fs from 'fs';
import * as path from 'path';
import { v4 as uuidv4 } from 'uuid';

/**
 * ZK-Proof Service
 * 
 * Handles zero-knowledge proof verification for Corporate Excellence 2025
 * NFT ownership authentication. Provides privacy-preserving verification
 * without revealing user identities or wallet addresses.
 */

export class ZKProofService {
    private verificationKey: any;
    private readonly CORPORATE_EXCELLENCE_CONTRACT = '0x742d35Cc6634C0532925a3b8D8B5d3d8c0eF7e95';

    constructor() {
        this.loadVerificationKey();
    }

    /**
     * Load the verification key from the circuits workspace
     */
    private loadVerificationKey(): void {
        try {
            const vkeyPath = path.join(__dirname, '..', 'zkp', 'verification_key.json');
            
            if (!fs.existsSync(vkeyPath)) {
                throw new Error(`Verification key not found at ${vkeyPath}`);
            }

            this.verificationKey = JSON.parse(fs.readFileSync(vkeyPath, 'utf8'));
            console.log('üîë ZK-proof verification key loaded successfully');
            console.log(`   - Protocol: ${this.verificationKey.protocol}`);
            console.log(`   - Curve: ${this.verificationKey.curve}`);
            console.log(`   - Public inputs: ${this.verificationKey.nPublic}`);

        } catch (error) {
            console.error('üí• Failed to load verification key:', error);
            throw new Error('ZK-proof verification key initialization failed');
        }
    }

    /**
     * Verify a zero-knowledge proof of NFT ownership
     * 
     * @param proof - The zk-SNARK proof generated by the mobile wallet
     * @param publicSignals - Public signals from the proof generation
     * @returns Promise<boolean> - True if the proof is valid
     */
    async verifyNFTOwnershipProof(proof: any, publicSignals: string[]): Promise<boolean> {
        try {
            console.log('üîç Starting ZK-proof verification process...');
            console.log('üìä Verification details:');
            console.log(`   - Public signals: ${publicSignals.length} values`);
            console.log(`   - Expected NFT contract: ${this.CORPORATE_EXCELLENCE_CONTRACT}`);

            // Validate proof structure
            if (!this.isValidProofStructure(proof)) {
                console.log('‚ùå Invalid proof structure');
                return false;
            }

            // Validate public signals
            if (!this.isValidPublicSignals(publicSignals)) {
                console.log('‚ùå Invalid public signals');
                return false;
            }

            // Log verification attempt (no sensitive data)
            console.log('üîê Verifying ZK-proof with Groth16...');
            const startTime = Date.now();

            // Perform the actual zk-SNARK verification using SnarkJS
            const isValid = await snarkjs.groth16.verify(
                this.verificationKey,
                publicSignals,
                proof
            );

            const verificationTime = Date.now() - startTime;
            console.log(`‚è±Ô∏è  Groth16 verification completed in ${verificationTime}ms`);

            if (isValid) {
                console.log('‚úÖ ZK-proof verification successful!');
                console.log('üéâ Privacy-preserving NFT ownership confirmed');
                console.log('üîí User identity remains completely anonymous');
            } else {
                console.log('‚ùå ZK-proof verification failed');
                console.log('üö´ Invalid proof or user does not own required NFT');
            }

            return isValid;

        } catch (error) {
            console.error('üí• ZK-proof verification error:', error);
            console.log('üîç Error details:');
            console.log(`   - Error type: ${error instanceof Error ? error.constructor.name : 'Unknown'}`);
            console.log(`   - Error message: ${error instanceof Error ? error.message : 'Unknown error'}`);
            
            return false;
        }
    }

    /**
     * Generate an authentication challenge for ZK-proof flow
     * 
     * @returns Object containing challenge data
     */
    generateAuthChallenge(): any {
        const challenge = {
            challengeId: uuidv4(),
            timestamp: Date.now(),
            nftContract: this.CORPORATE_EXCELLENCE_CONTRACT,
            requiredProof: 'NFT_OWNERSHIP',
            expiresAt: Date.now() + (5 * 60 * 1000), // 5 minutes expiry
            instructions: {
                step1: 'Generate ZK-proof using your mobile wallet',
                step2: 'Submit proof to /api/auth/verify-zkp endpoint',
                step3: 'Receive anonymous premium access token',
                privacy: 'Your wallet address will never be revealed'
            }
        };

        console.log(`üéØ Generated auth challenge: ${challenge.challengeId}`);
        console.log(`   - NFT Contract: ${challenge.nftContract}`);
        console.log(`   - Expires: ${new Date(challenge.expiresAt).toISOString()}`);

        return challenge;
    }

    /**
     * Validate the structure of a zk-SNARK proof
     * 
     * @param proof - Proof object to validate
     * @returns boolean - True if structure is valid
     */
    private isValidProofStructure(proof: any): boolean {
        if (!proof || typeof proof !== 'object') {
            console.log('‚ùå Proof is not an object');
            return false;
        }

        // Check for required Groth16 proof components
        const requiredComponents = ['pi_a', 'pi_b', 'pi_c'];
        
        for (const component of requiredComponents) {
            if (!proof[component]) {
                console.log(`‚ùå Missing proof component: ${component}`);
                return false;
            }

            if (!Array.isArray(proof[component])) {
                console.log(`‚ùå Proof component ${component} is not an array`);
                return false;
            }
        }

        // Validate pi_a (G1 point - 3 elements)
        if (proof.pi_a.length !== 3) {
            console.log('‚ùå Invalid pi_a length (expected 3 elements)');
            return false;
        }

        // Validate pi_b (G2 point - 3 elements, each with 2 sub-elements)
        if (proof.pi_b.length !== 3) {
            console.log('‚ùå Invalid pi_b length (expected 3 elements)');
            return false;
        }

        for (let i = 0; i < 2; i++) {
            if (!Array.isArray(proof.pi_b[i]) || proof.pi_b[i].length !== 2) {
                console.log(`‚ùå Invalid pi_b[${i}] structure`);
                return false;
            }
        }

        // Validate pi_c (G1 point - 3 elements)
        if (proof.pi_c.length !== 3) {
            console.log('‚ùå Invalid pi_c length (expected 3 elements)');
            return false;
        }

        console.log('‚úÖ Proof structure validation passed');
        return true;
    }

    /**
     * Validate public signals from the proof
     * 
     * @param publicSignals - Array of public signals
     * @returns boolean - True if signals are valid
     */
    private isValidPublicSignals(publicSignals: string[]): boolean {
        if (!Array.isArray(publicSignals)) {
            console.log('‚ùå Public signals is not an array');
            return false;
        }

        if (publicSignals.length === 0) {
            console.log('‚ùå Public signals array is empty');
            return false;
        }

        // Validate that all signals are valid field elements (strings representing big integers)
        for (let i = 0; i < publicSignals.length; i++) {
            const signal = publicSignals[i];
            
            if (typeof signal !== 'string') {
                console.log(`‚ùå Public signal ${i} is not a string`);
                return false;
            }

            // Check if it's a valid numeric string
            if (!/^\d+$/.test(signal)) {
                console.log(`‚ùå Public signal ${i} is not a valid numeric string`);
                return false;
            }

            // Check for reasonable bounds (BN254 field size)
            try {
                const signalBigInt = BigInt(signal);
                const fieldSize = BigInt('21888242871839275222246405745257275088548364400416034343698204186575808495617');
                
                if (signalBigInt >= fieldSize) {
                    console.log(`‚ùå Public signal ${i} exceeds field size`);
                    return false;
                }
            } catch (error) {
                console.log(`‚ùå Public signal ${i} conversion to BigInt failed`);
                return false;
            }
        }

        console.log(`‚úÖ Public signals validation passed (${publicSignals.length} signals)`);
        return true;
    }

    /**
     * Get verification service statistics
     * 
     * @returns Object containing service stats
     */
    getServiceStats(): any {
        return {
            service: 'ZK-Proof Verification Service',
            status: 'active',
            protocol: this.verificationKey?.protocol || 'unknown',
            curve: this.verificationKey?.curve || 'unknown',
            nftContract: this.CORPORATE_EXCELLENCE_CONTRACT,
            publicInputs: this.verificationKey?.nPublic || 0,
            features: [
                'Zero-knowledge NFT ownership verification',
                'Privacy-preserving authentication',
                'Anonymous premium access tokens',
                'Groth16 zk-SNARK verification',
                'Corporate Excellence 2025 NFT support'
            ],
            privacy: {
                walletAddressHidden: true,
                identityPreserving: true,
                zeroKnowledgeProofs: true,
                anonymousAccess: true
            }
        };
    }
}

export default ZKProofService;
